---
title: "EDA XI Multiple Correspondance Analysis"
subtitle: "Statistiques Master I, MFA et MIDS"
author: "Stéphane Boucheron"
institute: "Université de Paris"
date: "2020/12/11 (updated: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
    css: ["header-...ter.css", "xaringan-themer.css"]
    lib_dir: libs
    seal: false
    includes:
      in_header:
        - 'toc.html'
    nature:
      nature:
      slideNumberFormat: |
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: calc(%current% / %total% * 100%);">
          </div>
        </div>
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
name: inter-slide
class: left, middle, inverse

{{ content }}

---
name: layout-general
layout: true
class: left, middle

```{r setup, child="loaders_fixers.Rmd", echo=FALSE, message=FALSE, warning=FALSE}

```


```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
pacman::p_load("ggdendro")
pacman::p_load("fastcluster")
pacman::p_load("mixdist")
pacman::p_load("factoextra")
data("iris")
data("pearson")
```


```{r, load_refs, echo=FALSE, cache=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
pacman::p_load(RefManageR, quietly = TRUE)
BibOptions(check.entries = FALSE,
           bib.style = "authoryear",
           cite.style = 'authoryear',
           style = "markdown",
           hyperlink = FALSE,
           dashed = FALSE)
myBib <- ReadBib("./mon_chapeau.bib", check = FALSE, )
```

```{r, eval=TRUE, echo=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
NoCite(myBib, "HaTiFr01")
NoCite(myBib, "Mur12")
NoCite(myBib, "moitra2018algorithmic")
NoCite(myBib, "MR767260")
NoCite(myBib, "MR2445017")
```

---
class: middle, left, inverse

# Exploratory Data Analysis XI: Multiple Correspondance Analysis

### `r Sys.Date()`

#### [EDA Master I MIDS et MFA](http://stephane-v-boucheron.fr/courses/eda)

#### [Stéphane Boucheron](http://stephane-v-boucheron.fr)

---
class: middle, inverse

## `r fontawesome::fa("map", fill="white")`

### [Motivation](#bigpic)

### [Variants on mosaicplot](#variant-mosaic)

### [Indicator matrix](#indic-matrix)

### [MCA as CA on indicator matrix](#mca-in-words)

### [Illustrations](#)

???

### [CCA](#cca)


---
name: bigpic
template: inter-slide

## Motivation


```{r, warning=FALSE, echo=FALSE, message=FALSE}
require(tidyverse)
require(FactoMineR)
require(factoextra)
require(FactoInvestigate)
```

---

The aim of multiple correspondence analysis (MCA) is to summarise and visualise
a data table where individuals are described by _qualitative_ variables.

MCA is used to study the similarities between individuals from the point of
view of all the variables and identify individuals' profiles

MCA is also used to assess relationships between variables and study the associations between categories

As with PCA and CA, the individuals or groups of individuals
(rows) can be connected with categories of  variables (columns)

.fr.f6[From _R for statistics_, Cornillon et al. Chapman & Hall. Pub.]


`mca` is a Multiple Correspondence Analysis (MCA) package for `r fontawesome::fa("python")`, intended to be used with `pandas`. MCA is a feature extraction method; essentially PCA for categorical variables.

.fr.f6[[mca homepage](https://github.com/esafak/mca)]

???

Take-home message: MCA is a matrix factorization based method for exploring samples of categorical variables

Questions:

- Transforming samples of categorical variables into matrices
- SVD Factorization
- Relating the factors to the original data

---

### Questionnaires



[](https://en.wikipedia.org/wiki/Questionnaire)


???

Questionnaires:

- Definition
- Usage
- Example
- Interpretation

---
exclude: true

### Example: Questionnaire based on fictitious case reports


[Case report on Wikipedia](https://en.wikipedia.org/wiki/Case_report)


???

- Definition of  case report
- Usage of fictitious case report
-

---

### `r fontawesome::fa("coffee")` FactoMineR

<iframe src="http://factominer.free.fr/factomethods/multiple-correspondence-analysis.html"  width="750px" height="400px"></iframe>

---

### Handling more than 2 qualitative variables

Example `r fontawesome::fa("ship")` Titanic data set

$$\begin{array}{ll}\text{Demographic} & = \begin{cases}\text{Embarked} \\
\text{Sex} \\ \text{Passenger class} \\
\text{Age (Child/Adult)} \end{cases} \\ \text{Attitudinal} & =  \text{Survived}\end{array}$$

???

When handling a collection of qualitative variables, we may face several kinds of situations.

- we may investigate attitudinal variables with respect to  demographic variables
- we may investigate collections of  attitudinal variables
- we may investigate collections of demographic variables

MCA is geared towards investigating collections of variables of similar status

---

```{r, echo=FALSE}

tit_col_types = cols(

  PassengerId = col_integer(),

  Survived = col_factor(levels=c("0", "1"),   #<<
                        include_na = TRUE),   #<<

  Pclass = col_factor(levels=c("1", "2", "3"),  #<<
                      ordered = TRUE,           #<<
                      include_na = TRUE),       #<<

  Sex = col_factor(levels = c("female", "male")),
  Age = col_double(),
  SibSp = col_integer(),
  Parch = col_integer(),

  Embarked = col_factor(levels = c("S", "C", "Q"),
                        include_na = TRUE)
)
train <- read_csv("DATA/titanic/train.csv",
          col_types=tit_col_types)
test <- read_csv("DATA/titanic/test.csv",
          col_types=tit_col_types)

test <- mutate(test, #<<
               Survived=NA)  #<<

tit <- union(train,
             test)

tit$Survived <- forcats::fct_recode(tit$Survived,      #<<
                                    "Deceased"="0",    #<<
                                    "Survived"="1") %>%   #<<
                          forcats::fct_relevel(c("Survived", "Deceased")) #<<

tit$Age <-
  cut(tit$Age,
      breaks = c(0, 18, 100),
      labels=c("Child", "Adult")) %>%
  fct_explicit_na("NA.A")


tit %>%
  select(Sex, Age, Embarked, Pclass) %>%
  head()

```

---

### Mosaicplots for `n`-ways contingency tables


```{r, echo=FALSE}
# mosaicplot(Titanic, color = TRUE)
vcd::mosaic(x=Titanic)
```

???


```{r, eval=FALSE}
tit %>%
  dplyr::select(Pclass, Embarked) %>%
  drop_na() %>%
  ggplot() +
  geom_mosaic(aes(x = product(Embarked, Pclass), fill=Embarked)) +
  labs(x= "Passenger class", y="Embarked") +
  scale_fill_viridis_d() +
  ggtitle("Titanic mosaic with tidyverse flavor")
```

---
name: variant-mosaic
template: inter-slide


## Variations on Mosaicplot

---

### Mosaic plots versus Association plots


> In order to explain multi-dimensional categorical data, statisticians typically look for (conditional) independence structures

> Whether the task is purely exploratory or model-based, techniques such as _mosaic_ and _association_ plots offer good support for visualization

.fr.f6[Structplot vignette]

???

> Both _mosaic_ and _association_ plots visualize aspects of (possibly higher-dimensional) contingency tables, with several extensions


---

### Extensions

- double-decker plots

- spine plots

- spinograms

- conditional association plots


---

### `r fontawesome::fa("university")` Order matters


```{r, out.width="50%", fig.show='hold'}

aperm(UCBAdmissions, c(3, 2, 1)) %>% mosaicplot(shade=TRUE)

aperm(UCBAdmissions, c(3, 2, 1)) %>% vcd::mosaic(shade=TRUE)
```

---

### Double decker plot for  `UCBAdmissions`

.fl.w-60.pa2[

```{r}
aperm(UCBAdmissions, c(3, 2, 1)) %>%
  vcd::doubledecker()
```
.f6[
- Per department admissions exhibit no clear bias against
women
- Men tend to fill more applications to less selective departments
]
]

.fl.w-40.pa2.f6[

[Simpson's paradox](https://en.wikipedia.org/wiki/Simpson%27s_paradox)

> A trend appears in several different groups of data but disappears or reverses when these groups are combined

> This result is often encountered in social-science and medical-science statistics and is particularly problematic when frequency data is unduly given causal interpretations.

> The paradox is also referred to as Simpson's reversal, Yule–Simpson effect, amalgamation paradox, or reversal paradox

.fr[Wikipedia]

]


???

A double decker plot is a collection of stacked column/bar plots: For each
department, we have a column plot where `Gender` is mapped to `x` and `Admit`
to `y`. Columns are stacked. Width is proportional to number of applicants
with given Gender for the department. Height is proportional to fraction
of successful/failing applicants for given  Department and Gender

---

### Flattening Titanic table


```{r, eval=FALSE}
pacman::p_load(xtable)
vcd::structable(~ Class + Age + Sex, aperm(Titanic, c(1,3,2, 4))) %>%
  xtable::xtableFtable()
```





|  Class | Sex    |     |  Child|  Adult|
|:------:|:-------|-----|------:|------:|
|1st     |Male   |      |     5 |   175 |
|        | Female |     |     1 |   144 |
|  2nd   | Male   |     |    11 |   168 |
|        | Female |     |    13 |    93 |
|  3rd   | Male   |     |    48 |   462 |
|        | Female |     |    31 |   165 |
|  Crew  | Male   |     |     0 |   862 |
|        | Female |     |     0 |    23 |

---

Double-decker plot for the Titanic data

```{r}
vcd::doubledecker(Titanic)
```

---


```{r}
knitr::include_url("https://rdrr.io/cran/vcd/")
```
---
###  Strucplot framework

- low-level grapcon functions
  - created by generating functions (grapcon generators)
  - `group_...`, `struc_...`, `labelling_...`, `legend_...`, `spacing_...`
- a suitable combination of the low-level grapcon
functions is passed as “hyperparameters” to strucplot()
- convenience functions such as
mosaic(), sieve(), assoc(), and doubledecker() which interface strucplot()

???


> The strucplot framework is highly modularized: Figure 5 shows the hierarchical relationship between the various components. On the lowest level, there are several groups of
workhorse and parameter functions that directly or indirectly influence the final appearance of the plot (see Table 2 for an overview). These are examples of grapcon functions.
They are created by generating functions (grapcon generators), allowing flexible parameterization and extensibility (Figure 5 only shows the generators). The generator names follow the
naming convention group_... (), where group reflects the group the generators belong to
(strucplot core, labeling, legend, shading, or spacing). The workhorse functions (created by
struc_... (), labeling_... (), and legend_... ()) directly produce graphical output (i.e.,
“add ink to the canvas”), whereas the parameter functions (created by spacing_... () and
shading_... ()) compute graphical parameters used by the others. The grapcon functions
returned by struc_... () implement the core functionality, creating the tiles and their content. On the second level of the framework, a suitable combination of the low-level grapcon
functions (or, alternatively, corresponding generating functions) is passed as “hyperparameters” to strucplot(). This central function sets up the graphical layout using grid viewports
(see Figure 6), and coordinates the specified core, labeling, shading, and spacing functions
to produce the plot. On the third level, we provide several convenience functions such as
mosaic(), sieve(), assoc(), and doubledecker() which interface strucplot() through
sensible parameter defaults and support for model formulae. Finally, on the fourth level,
there are “related” vcd functions (such as cotabplot() and the pairs() methods for table
objects) arranging collections of plots of the strucplot framework into more complex displays
(e.g., by means of panel functions)


---
name: indic-matrix
template: inter-slide

## Indicator matrix


---

### `r fontawesome::fa("binoculars")` Two perspectives

MCA can be viewed along two perspectives:

- Analyzing the dataset after performing _one-hot_ encoding of categorical variables.
The

- Analyzing all two-way contingency tables derived from the dataset

???

The two perspective define different pipelines


---

### A glimpse at the indicator matrix

.f6[

```{r}
Z <- tit %>%
  select(Sex, Age, Embarked, Pclass) %>%
  tab.disjonctif() #<<

Z %>% head() %>% knitr::kable()
```

]

???


```{r, echo=TRUE}
mca.tit <- tit %>%
  select(Sex, Age, Embarked, Pclass, Survived) %>%
  FactoMineR::MCA(quali.sup= c(5), graph = FALSE)  #<<

Z <- mca.tit$call$Xtot      #<<

# Z %>%  head() %>% knitr::kable()
```


Comment on "quali.sup" and other optional arguments to `MCA`

---

### Construction of indicator matrix

- A categorical variable $V_j$ (factor) with $q$ levels is mapped to $q$ $\{0,1\}$ -valued variables $V_{j,r}$ for $r \leq q$

- If levels are indexed by $\{1, \ldots, q\}$, if the value of the categorical variable $V_j$ from row $i$  is $k \in \{1, \ldots, q\}$, the binary variables $V_{j,r}$ on that row take values 
$$k \mapsto \underbrace{0,\ldots, 0}_{k-1}, 1, \underbrace{0, \ldots, 0}_{q-k}$$

- In Machine Learning parlance building  the indicator matrix consists of performing _one-hot encoding_ for each categorical variable

- The indicator matrix has as many rows as the data matrix

- The number of columns of the indicator matrix is the sum of the number of levels of the categorical variables/columns of the data matrix

- The indicator matrix is a numerical matrix. It is suitable for factorial methods `r fontawesome::fa("smile")` 


???


---

### The Burt matrix

.fl.w-40.pa2.f6[

- Multiple Correspondance Analysis may be based on the Burt matrix

- The Burt matrix is a symmetric integer-valued matrix made of blocks consisting 
of 2-ways contingency tables

- Each block is the contingency table defined by two categorical variables from the data matrix

- Diagonal blocks are diagonal sub-matrices

]

.fl.w-60.pa2.f6[

```{r}
B <- t(Z) %*% as.matrix(Z)

B[1:6, 1:6] %>% knitr::kable()
```

]

---
class: inter-slide
name: mca-in-words

## MCA in words

---

### MCA

MCA consists of performing CA (correspondance analysis)  on the indicator matrix


```{r}
mca.tit.mano <- FactoMineR::CA(Z) #<<
```


```{r}
U <- mca.tit.mano$svd$U   # orthogonal columns
V <- mca.tit.mano$svd$V   # orthogonal w.r.t.
D <- diag(mca.tit.mano$svd$vs[1:5])

colSums(U %*% D %*% t(V))

norm(scale(Z, scale=FALSE) - (U %*% D %*% t(V)),type = "F" )

t(V) %*% V
```

???

- centering $Z$
- extended SVD with respect to two diagonal matrices
- all row sums of $Z$ are equal to the number of categorical variables in the initial dataset
- column sums count number of occurrences of categories in the initial dataset


---



---

### CA executive summary




???



---
name: visualizations


### Visualization



---

### Burt matrix

All pairwise contingency tables

$$B =  Z^T \times Z$$

---

### MCA


> Multiple Correspondence Analysis (MCA)

> Performs Multiple Correspondence Analysis (MCA) with supplementary individuals, supplementary quantitative variables and supplementary categorical variables.

> Performs also Specific Multiple Correspondence Analysis with supplementary categories and supplementary categorical variables.

> Missing values are treated as an additional level, categories which are rare can be ventilated

???

- supplementary categories and

- supplementary categorical variables

- ventilated:

---

### Result of `MCA`


Returns a list including:

`eig`
a matrix containing all the eigenvalues, the percentage of variance and the cumulative percentage of variance

`var`
a list of matrices containing all the results for the active variables (coordinates, square cosine, contributions, v.test, square correlation ratio)

`ind`
a list of matrices containing all the results for the active individuals (coordinates, square cosine, contributions)

`ind.sup`
a list of matrices containing all the results for the supplementary individuals (coordinates, square cosine)

`quanti.sup`
a matrix containing the coordinates of the supplementary quantitative variables (the correlation between a variable and an axis is equal to the variable coordinate on the axis)

`quali.sup`
a list of matrices with all the results for the supplementary categorical variables (coordinates of each categories of each variables, square cosine and v.test which is a criterion with a Normal distribution, square correlation ratio)

`call`
a list with some statistics

---

### Zooming on `call`

- "X" : original dataset
- "marge.col" :
- "marge.row"
- "ncp" : number of components to retain
- "row.w": row weights
- "excl"
- "call"
- "Xtot":  (possibly augmented) indicator matrix
- "N":
- "col.sup":
- "quali"
- "quali.sup"

???

Leaving aside


---

### `credit` dataset

- A survey

- Demographic variables

- Attitudinal variables

---

### `MCA` from the `FactoMineR` package.

.fl.w-40.pa2[
```{r, message=FALSE}
fpath <- "./DATA/credit.csv"

credit <- read_csv2(fpath) %>%
  mutate(across(where(is.character),
                factor)
         )

credit$Age <- credit$Age %>%
  as_factor() %>%
  fct_inseq()
```
]

.fl.w-60.pa2.f6[

```{r, echo=FALSE}
credit %>% glimpse(width = 40)
```


]

- Columns 1 to 5 `Marche`, ..., `Endettement` are concerned with _attitudes_
- Column 6 to 11 are concerned with _demographics_


---
exclude: true

### Handling rare categories



---
exclude: true

### Spotting rare categories.

```{r, eval=FALSE, echo=FALSE}
rare_categories <- credit %>%
  map(table) %>%
  map(~ which(. <= 10))

 rare_categories <- rare_categories[which(rare_categories %>%
                        map(length) >0)]
```

---

### Handling rare categories for `Marche`, `Enfants`, `Logement`

.panelset[

.panel[ .panel-name[`Marche`]
```{r, echo=TRUE}

credit$Marche <- fct_collapse(credit$Marche,
  "Mobilier / Ameublement" = "Mobilier / Ameublement",
  "Renovation" = "Renovation",
  "Moto" = c ("Moto", "Scooter", "Side-car"),
  "Voiture" = "Voiture")
```
]

.panel[ .panel-name[`Enfants`]
```{r}
credit$Enfants <- credit$Enfants %>%
  fct_lump(n = 3, other_level = "Enf>2")
```
]

.panel[ .panel-name[`Logement`]

```{r}
credit$Logement <- credit$Logement %>%
  fct_collapse(
    "Accedant a la propriete"="Accedant a la propriete",
    "Locataire"="Locataire",
    "Loge par ..." = c("Loge par l'employeur",
                       "Loge par la famille"),
    "Proprietaire"="Proprietaire")
```
]

]

---

### MCA over attitude variables

```{r}
res.mca <- credit %>%
  FactoMineR::MCA(graph = FALSE,
                  quali.sup = 6:11)
```

---

### Screeplot

.fl.w-60.pa2[

```{r, echo=FALSE}
qplot(x=as_factor(seq_along(res.mca$eig[, 2])), y=res.mca$eig[, 2]) +
  geom_col() +
  ylab("Eigenvalues") +
  xlab("") +
  ggtitle("MCA screeplot", "credit data, attitudinal variables")
```

The first two dimensions express $\approx 30\%$ of the total variance,
which is relatively high in MCA  `r fontawesome::fa("smile")`

]

.fl.w-40.pa2.f6[

```{r, results='markup', eval=FALSE, echo=FALSE}
res.mca$eig%>%
  knitr::kable(format="markdown", digits = 2)
```

|Dim.   | Eigenvalue| `%` of inertia | cumul. `%` of inertia|
|:-----:|----------:|---------------:|---------------------:|
| 1  |       0.39|           16.26|                  16.26|
| 2  |       0.32|           13.37|                  29.63|
| 3  |       0.29|           12.15|                  41.79|
| 4  |       0.27|           11.33|                  53.12|
| 5  |       0.23|            9.38|                  62.50|
| 6  |       0.18|            7.68|                  70.19|
| 7  |       0.17|            7.09|                  77.27|
| 8  |       0.16|            6.73|                  84.00|
| $\vdots$ | $\vdots$ | $\vdots$ | $\vdots$ |

]


---

### Graphics

Object `res.mca` belongs to class `MCA`

Class `MCA`  has its own `plot` method

The MCA function yields a graph simultaneously representing individuals and
categories (active and illustrative) on the first two dimensions.

This representation quickly becomes messy.

---

### Plotting individuals

Making variables whether active or not, _invisible_

```{r}
plot(res.mca, invisible=c("var","quali.sup"))
```

---

### Clustering individuals

We can use
the colour aesthetic to check whether some pattern emerges.

```{r}
plot(res.mca, invisible=c("var","quali.sup"), habillage="Marche")
```

Does it?

---

### Colouring according to profession

```{r}
plot(res.mca, invisible=c("var","quali.sup"), habillage="Profession")
```


---

### Colouring according to Age

```{r}
plot(res.mca, invisible=c("var","quali.sup"), habillage="Age")
```


---

### Colouring according to Impaye

```{r}
plot(res.mca, invisible=c("var","quali.sup"), habillage="Impaye")
```

---

> Dimension 2 mainly opposes people in great financial difficulty (below) with
the others (above). We can therefore identify people who have difficulty paying
back their loan (three or more payments missed) and those who have taken
out TPD insurance. This dimension can thus be qualified as the dimension of financial difficulty.


---

### Plotting variables

```{r}
plot(res.mca, choix="var", invisible = "quali.sup")
```

---


```{r}
plot(res.mca, choix="var")
```

---

```{r}
plot(res.mca, invisible=c("ind", "quali.sup"))
```

---

### AUtomatic report

```{r, eval=FALSE}
FactoInvestigate::Investigate(res.mca, keepRmd = TRUE)
```

---

### Dimension description

Automatically describing the dimensions of variability.

This function also sorts the qualitative
variables as well as the categories of the qualitative variables. In order to do
so, a one-way analysis of variance model is constructed for
each qualitative variable: variable Y corresponds to the principal component
(the coordinates of the individuals or scores) and is explained according to a
qualitative variable.

---

The _p-value_ of the overall test (F-test) is calculated as
well as the p-values of the tests of each category.  The p-values
associated with the F-tests are sorted in ascending order. Thus, the qualitative
variables are sorted from most to least characteristic. In the same way,
the p-values of the t-tests by categories are sorted (in ascending order when
the coefficient is positive, and in descending order when it is negative). This
will identify the most characteristic categories.

---

```{r}
FactoMineR::dimdesc(res.mca)
```


---

### Packages

- `r fontawesome::fa("r-project")` [FactoMineR]()
- `r fontawesome::fa("r-project")` [ade4]()


- `r fontawesome::fa("python")` [prince](https://github.com/MaxHalford/prince)
- `r fontawesome::fa("python")` []()

---

## Bibliographical remarks


---
class: middle, center, inverse

background-image: url('./img/pexels-cottonbro-3171837.jpg')
background-size: cover


# The End
